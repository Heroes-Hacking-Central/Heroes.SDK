using System.Runtime.InteropServices;
using Heroes.SDK.Definitions.Structures.Object.Hint.Enum;

namespace Heroes.SDK.Definitions.Structures.Object.Hint
{
    [StructLayout(LayoutKind.Sequential, Size = 12)]
    public struct Entry
    {
        public static Entry Null = new Entry(0, HintCharacter.Sonic, 0, 0, 0);

        /// <summary>
        /// Number of the hint which matches the number in the object layout file.
        /// </summary>
        public short HintNumber         { get; set; }

        /// <summary>
        /// The character which triggers this hint.
        /// </summary>
        public HintCharacter HintCharacter      { get; set; }

        /// <summary>
        /// Offset of the hint relative to the end of the hint section.
        /// </summary>
        public int Offset               { get; set; }

        /// <summary>
        /// Amount of frames the hint is shown.
        /// </summary>
        public short ShowDuration       { get; set; }

        /// <summary>
        /// Index of the next hint to play after this hint completes.
        /// The index is the order it appears in the final file.
        /// </summary>
        public short NextHint           { get; set; }

        public Entry(short hintNumber, HintCharacter hintCharacter, int offset, short showDuration, short nextHint)
        {
            HintNumber      = hintNumber;
            HintCharacter       = hintCharacter;
            Offset          = offset;
            ShowDuration    = showDuration;
            NextHint        = nextHint;
        }

        /// <summary>
        /// Creates an entry from a managed entry.
        /// Note: Offset field is not calculated, will need to be calculated at time to writing to file.
        /// </summary>
        public Entry(ManagedEntry entry)
        {
            HintNumber = entry.HintNumber;
            HintCharacter = entry.HintCharacter;
            ShowDuration = entry.ShowDuration;
            NextHint = entry.NextHint;
            Offset = 0;
        }

        /* Autogenerated by R# */
        public static bool operator !=(Entry a, Entry b)
        {
            return !a.Equals(b);
        }

        public static bool operator ==(Entry a, Entry b)
        {
            return a.Equals(b);
        }

        public bool Equals(Entry other)
        {
            return HintNumber == other.HintNumber &&
                   HintCharacter == other.HintCharacter &&
                   Offset == other.Offset &&
                   ShowDuration == other.ShowDuration &&
                   NextHint == other.NextHint;
        }

        public override bool Equals(object obj)
        {
            return obj is Entry other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = HintNumber.GetHashCode();
                hashCode = (hashCode * 397) ^ (int)HintCharacter;
                hashCode = (hashCode * 397) ^ Offset;
                hashCode = (hashCode * 397) ^ ShowDuration.GetHashCode();
                hashCode = (hashCode * 397) ^ NextHint.GetHashCode();
                return hashCode;
            }
        }
    }
}
